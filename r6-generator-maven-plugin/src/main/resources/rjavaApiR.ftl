# Generated by r6-generator-maven-plugin: do not edit by hand
#' This is the main entry point of the ${model.getConfig().getPackageName()} generated R library.
#'
#' @description
#' ${model.getConfig().getTitle()}
#'
#' Version: ${model.getConfig().getVersion()}
#'
#' Generated: ${model.getConfig().getDate()}
#'
#' Contact: ${model.getConfig().getMaintainerEmail()}
<#--
We don't really want these imported in this way, but the package level
imports are needed to make sure that they are used in the NAMESPACE file
and hence stops CRAN from emitting a warning about them not being used.
In short it is another CRAN special. 
-->
#' @import R6
<#list model.getImports() as import>
#' @import ${import}
</#list>	
#' @import rJava 
#' @export
JavaApi = R6::R6Class("JavaApi", public=list( 
	#### fields ----
	#' @field .log a pointer to the java logging system
	.log = NULL,
	#' @field .fromJava a set of type conversion functions from Java to R
	.fromJava = NULL,
	#' @field .toJava a set of type conversion functions from R to Java
	.toJava = NULL,
	#' @field .reg the list of references to java objects created by this API 
	.reg = list(),
<#list model.getClassTypes() as class>
	#' @field ${class.getSimpleName()} the ${class.getSimpleName()} class constructors and static methods
	${class.getSimpleName()} = NULL,
</#list>

	#' @description
	#' change the java logging level
	#' @param logLevel A string such as "DEBUG", "INFO", "WARN"
	#' @return nothing
	changeLogLevel = function(logLevel) {
		.jcall("uk/co/terminological/rjava/LogController", returnSig = "V", method = "changeLogLevel" , logLevel)
		invisible(NULL)
	},
	
	#' @description
	#' change the java logging level using a log4j configuration file
	#' @param log4jproperties An absolute filepath to the log4j propertied file
	#' @return nothing
	reconfigureLog = function(log4jproperties) {
		.jcall("uk/co/terminological/rjava/LogController", returnSig = "V", method = "reconfigureLog" , log4jproperties)
		invisible(NULL)
	},
	
	#' @description
	#' print java system messages to the R console and flush the message cache. This is generally called automatically,
	#' @return nothing
	printMessages = function() {
		# check = FALSE here to stop exceptions being cleared from the stack.
		msg = .jcall("uk/co/terminological/rjava/LogController", returnSig = "Ljava/lang/String;", method = "getSystemMessages", check=FALSE)
		if (!is.null(msg) && trimws(msg) != "") message(trimws(msg))
		invisible(NULL)
	},
	
 	#### constructor ----
 	#' @description
 	#' Create the R6 api library class. This is the entry point to all Java related classes and methods in this package.
	#' @param logLevel One of "OFF", "FATAL", "ERROR", "WARN", "INFO", "DEBUG", "TRACE", "ALL". (defaults to "${model.getConfig().getDefaultLogLevel()}") 
	#' @examples
	#' J = ${model.getConfig().getPackageName()}::JavaApi$get();
	#' @return nothing
 	initialize = function(logLevel = <#if model.getConfig().getDebugMode()>"DEBUG"<#else>"${model.getConfig().getDefaultLogLevel()}"</#if>) {
 		if (is.null(JavaApi$singleton)) stop("Startup the java api with JavaApi$get() rather than using this constructor directly")
 	
 		<#--
 		# TODO: if (substr(packageVersion("rJava"),1,1)=="0") { 
 		# 	use .jinit? at least for debugging mode.
 		#	you don't appear to be able to add parameters to .jpackage but .jinit will pick up the defaults
 		# } else { 
 		# 	use .jpackage with a custom class loader .jpackage(..., parameters=getOption("java.parameters"), own.loader=TRUE) 
 		#	and then everytime we use .jnew we need to pass .jnew(..., class.loader=.rJava.class.loader) I think.
 		#	currently the class.loader option exists in rJava < 1.0.0 but the value is NULL
 		#	this change will have to also be made in the API Rd file on a case specific basis.
 		#	the class loader probably ought to be a field in the API R6 class. plus maybe a wrapper for the .jnew method there 
 		# }
 		-->
 	
 		.startJvm()
		
		# Java dependencies
		jars = .checkDependencies(quiet = TRUE)
		.jaddClassPath(jars)
		
		# configure logging
 		.jcall("uk/co/terminological/rjava/LogController", returnSig = "V", method = "setupRConsole")
 		.jcall("uk/co/terminological/rjava/LogController", returnSig = "V", method = "configureLog" , logLevel)
 		# TODO: this is the library build date code but it requires testing
 		buildDate = .jcall("uk/co/terminological/rjava/LogController", returnSig = "S", method = "getClassBuildTime")
		self$.log = .jcall("org/slf4j/LoggerFactory", returnSig = "Lorg/slf4j/Logger;", method = "getLogger", "${model.getConfig().getPackageName()}");
		.jcall(self$.log,returnSig = "V",method = "debug", "Adding to classpath: ")
		for (jar in jars) {
		  .jcall(self$.log,returnSig = "V",method = "debug", jar)
		}
		.jcall(self$.log,returnSig = "V",method = "info","Initialised ${model.getConfig().getPackageName()}");
		.jcall(self$.log,returnSig = "V",method = "debug","R package version: ${model.getConfig().getVersion()}");
		.jcall(self$.log,returnSig = "V",method = "debug","R package generated: ${model.getConfig().getDate()}");
		.jcall(self$.log,returnSig = "V",method = "debug","Java library version: ${model.getMavenCoordinates()}");
		.jcall(self$.log,returnSig = "V",method = "debug",paste0("Java library compiled: ",buildDate));
		.jcall(self$.log,returnSig = "V",method = "debug","Contact: ${model.getConfig().getMaintainerEmail()}");
		self$printMessages()
		
		# initialise type conversion functions
		
		self$.toJava = list(
<#list model.getDataTypes() as data>
			${data.getSimpleName()}=<#list data.getInputRCode() as fnLine>${fnLine}<#sep>${'\n'}			</#list><#sep>,
</#list>
		)
		
		self$.fromJava = list(
<#list model.getDataTypes() as data>
			${data.getSimpleName()}=<#list data.getOutputRCode() as fnLine>${fnLine}<#sep>${'\n'}			</#list><#sep>,
</#list>
		)
	
		# initialise java class constructors and static method definitions
		
<#list model.getClassTypes() as class>
		self$${class.getSimpleName()} = list(
	<#assign method=class.getConstructor()>
			new = function(${method.getFunctionParameterCsv()}) {
				# constructor
				# convert parameters to java
	<#list method.getParameterNames() as param>
				tmp_${param} = self$.toJava$${method.getParameterType(param).getSimpleName()}(${param});
	</#list>
				# invoke constructor method
				tmp_out = .jnew("${class.getJNIName()}" ${method.getPrefixedParameterCsv("tmp_")}, check=FALSE);
				self$printMessages()
				.jcheck() 
				# convert result back to R (should be a identity conversion)
				tmp_r6 = ${class.getSimpleName()}$new(
					tmp_out,
					self
				);
				return(tmp_r6)
			}<#if (class.hasStaticMethods())>,</#if>
	<#list class.getStaticMethods() as method>
			${method.getName()} = function(${method.getFunctionParameterCsv()}) {
				# copy parameters
			<#list method.getParameterNames() as param>
				tmp_${param} = self$.toJava$${method.getParameterType(param).getSimpleName()}(${param});
			</#list>
			<#if method.isAsync()>
				# statically construct a JFuture R6 object as return value.
				# this uses the JFuture constructor with a canonical  name as a parameter. 
				# in which case we must supply the api
				out = RFuture$new(
					r6obj = "${class.getCanonicalName()}",
					converter = self$.fromJava$${method.getReturnType().getSimpleName()},
					returnSig = "${method.getReturnType().getJNIType()}", 
					method = "${method.getName()}"${method.getPrefixedParameterCsv("tmp_",5)},
					api = self
				);
				# handle any messages and exceptions arising:
				self$printMessages();
				.jcheck();
				<#if method.isFuture()>return(out)<#else>return(out$get())</#if>;
			<#else>
				# execute static call
				tmp_out = .jcall(
					"${class.getJNIName()}", 
					returnSig = "${method.getReturnType().getJNIType()}", 
					method = "${method.getName()}"${method.getPrefixedParameterCsv("tmp_",5)}, 
					check = FALSE);
				self$printMessages()
				.jcheck()
				# static methods cannot return themselves fluently, so this does not need to be checked for.
				# convert java object back to R. Wrapping in an R6 class as needed
				out = self$.fromJava$${method.getReturnType().getSimpleName()}(tmp_out);
				if(is.null(out)) return(invisible(out))
				return(out)
			</#if>
			}<#sep>,
	</#list>
	)
</#list>
	}
))

JavaApi$singleton = NULL

JavaApi$get = function(logLevel = <#if model.getConfig().getDebugMode()>"DEBUG"<#else>"${model.getConfig().getDefaultLogLevel()}"</#if>) {
	if (is.null(JavaApi$singleton)) {
		# set to non-null so that R6 constructor will work
		JavaApi$singleton = FALSE 
		JavaApi$singleton = JavaApi$new(logLevel)
	}
	return(JavaApi$singleton)
}

JavaApi$rebuildDependencies = function( ... ) {
	.startJvm()
	jars = .checkDependencies(nocache=TRUE, quiet=FALSE)
	if (!all(file.exists(jars))) {
		warning("The library has been rebuilt but there is still some missing dependencies: Out of the following")
		warning(paste0(jars,collapse="\n"))
		warning("The missing dependencies are:")
		warning(paste0(jars[file.exists(jars)],collapse="\n"))
		warning("Please double check this is not an issue with your connections etc")
		warning("The output of ${model.getConfig().getPackageName()}::JavaApi$rebuildDependencies(debug=TRUE) may help diagnose the problem")
	}
	
	return(jars)
}

JavaApi$installDependencies = function() {
	.startJvm()
	jars = .checkDependencies(nocache=FALSE, quiet=FALSE)
	.jaddClassPath(jars)
}

JavaApi$versionInformation = function() {
	out = list(
		package = "${model.getConfig().getPackageName()}",
		r_package_version = "${model.getConfig().getVersion()}",
		r_package_generated = "${model.getConfig().getDate()}",
		java_library_version = "${model.getMavenCoordinates()}",
		maintainer = "${model.getConfig().getMaintainerEmail()}"
	)
	# try and get complilation information if library is loaded
	try({
		out$java_library_compiled = .jcall("uk/co/terminological/rjava/LogController", returnSig = "S", method = "getClassBuildTime")
	}, silent=TRUE)
	return(out)
}

## package private utility functions for managing maven dependencies ----
# as this is generated code configuration is hard coded here
# i.e. these functions are specific for the configuration of this package.


.checkDependencies = function(nocache = FALSE, ...) {
	<#if model.getConfig().preCompileBinary()>
		<#if model.getConfig().packageAllDependencies()>
			<#if model.getConfig().useShadePlugin()>
	package_jar = .package_jars(package_name="${model.getConfig().getPackageName()}",types="shaded")
			<#else>
	package_jar = .package_jars(package_name="${model.getConfig().getPackageName()}",types="fat-jar")
			</#if>
		<#else>
	package_jar = .package_jars(package_name="${model.getConfig().getPackageName()}",types="thin-jar")
		</#if>
	<#else>
	package_jar = .package_jars(package_name="${model.getConfig().getPackageName()}",types="src")
	</#if>
	package_jar = package_jar[startsWith(fs::path_file(package_jar),"${model.getArtifactId()}-${model.getMavenVersion()}")]
	
	# Java dependencies
	<#if model.getConfig().preCompileBinary()>
		<#if model.getConfig().packageAllDependencies()>
	# all java library code and dependencies have already been bundled into a single fat jar
	# compilation was done on the library developers machine and has no external dependencies
	jars = package_jar
		<#else>
	# the main java library has been compiled but external dependencies must be resolved by maven
	# successful resolution of the classpath libraries depends on the runtime machine and requires
	# access to the internet at a minimum.
	maven_dependencies = .resolve_dependencies(artifact="${model.getMavenCoordinates()}", nocache=nocache, path=package_jar, ...)
	jars = .package_jars(package_name="${model.getConfig().getPackageName()}",types="thin-jar")
	# all jars in R package and maven dependencies
	jars = unique(c(jars,maven_dependencies))
		</#if>
	<#else>
	# this is a sources only distribution. The java code must be compiled from the source (distributed in this package as a ${model.getArtifactId()}-${model.getMavenVersion()}-src.jar) 
	# all the dependencies are resolved and packaged into a single fat jar on compilation
	# N.b. successful compilation is a machine specific thing as the dependencies may have been installed into maven locally 
	jars = .compile_jar(path=package_jar, nocache=nocache, with_dependencies=TRUE, ...)
	</#if>
	
	# find the jars that come bundled with the library:
	# and add any that have been resolved and downloaded by maven:
	return(jars)
}


.startJvm = function() {
	.start_jvm(debug=<#if model.getConfig().getDebugMode()>TRUE<#else>FALSE</#if>)
}

